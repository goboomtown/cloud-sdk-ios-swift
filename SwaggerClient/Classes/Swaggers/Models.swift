// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }

        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [ChatSend]
        Decoders.addDecoder(clazz: [ChatSend].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChatSend]> in
            return Decoders.decode(clazz: [ChatSend].self, source: source)
        }

        // Decoder for ChatSend
        Decoders.addDecoder(clazz: ChatSend.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChatSend> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChatSend() : instance as! ChatSend
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["response"] as AnyObject?) {
                
                case let .success(value): _result.response = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChatSend", actual: "\(source)"))
            }
        }
        // Decoder for [ChatSendRequest]
        Decoders.addDecoder(clazz: [ChatSendRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChatSendRequest]> in
            return Decoders.decode(clazz: [ChatSendRequest].self, source: source)
        }

        // Decoder for ChatSendRequest
        Decoders.addDecoder(clazz: ChatSendRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChatSendRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChatSendRequest() : instance as! ChatSendRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["from"] as AnyObject?) {
                
                case let .success(value): _result.from = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChatSendRequest", actual: "\(source)"))
            }
        }
        // Decoder for [CommonResponse]
        Decoders.addDecoder(clazz: [CommonResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CommonResponse]> in
            return Decoders.decode(clazz: [CommonResponse].self, source: source)
        }

        // Decoder for CommonResponse
        Decoders.addDecoder(clazz: CommonResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CommonResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CommonResponse() : instance as! CommonResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CommonResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CustomForm]
        Decoders.addDecoder(clazz: [CustomForm].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomForm]> in
            return Decoders.decode(clazz: [CustomForm].self, source: source)
        }

        // Decoder for CustomForm
        Decoders.addDecoder(clazz: CustomForm.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomForm> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomForm() : instance as! CustomForm
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["org_team_ids"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CustomFormField].self, source: sourceDictionary["fields"] as AnyObject?) {
                
                case let .success(value): _result.fields = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomForm", actual: "\(source)"))
            }
        }
        // Decoder for [CustomFormData]
        Decoders.addDecoder(clazz: [CustomFormData].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomFormData]> in
            return Decoders.decode(clazz: [CustomFormData].self, source: source)
        }

        // Decoder for CustomFormData
        Decoders.addDecoder(clazz: CustomFormData.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomFormData> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
            var propsDictionary = sourceDictionary
            let keys : [AnyHashable] = ["field"]
                let _result = instance == nil ? CustomFormData() : instance as! CustomFormData
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["field"] as AnyObject?) {
                
                case let .success(value): _result.field = value
                case let .failure(error): break
                
                }

                for key in keys {
                    propsDictionary.removeValue(forKey: key)
                }

                for key in propsDictionary.keys {
                    switch  Decoders.decodeOptional(clazz: String.self, source: propsDictionary[key] as AnyObject?) {

                    case let .success(value): _result[key] = value
                    default: continue

                    }
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomFormData", actual: "\(source)"))
            }
        }
        // Decoder for [CustomFormDataList]
        Decoders.addDecoder(clazz: [CustomFormDataList].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomFormDataList]> in
            return Decoders.decode(clazz: [CustomFormDataList].self, source: source)
        }

        // Decoder for CustomFormDataList
        Decoders.addDecoder(clazz: CustomFormDataList.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomFormDataList> in
            if let source = source as? CustomFormDataList {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias CustomFormDataList", actual: "\(source)"))
            }
        }
        // Decoder for [CustomFormField]
        Decoders.addDecoder(clazz: [CustomFormField].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomFormField]> in
            return Decoders.decode(clazz: [CustomFormField].self, source: source)
        }

        // Decoder for CustomFormField
        Decoders.addDecoder(clazz: CustomFormField.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomFormField> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomFormField() : instance as! CustomFormField
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["label"] as AnyObject?) {
                
                case let .success(value): _result.label = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["default_value"] as AnyObject?) {
                
                case let .success(value): _result.defaultValue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: HashMapOfStrings.self, source: sourceDictionary["list_items"] as AnyObject?) {
                
                case let .success(value): _result.listItems = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomFormField", actual: "\(source)"))
            }
        }
        // Decoder for [Customer]
        Decoders.addDecoder(clazz: [Customer].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Customer]> in
            return Decoders.decode(clazz: [Customer].self, source: source)
        }

        // Decoder for Customer
        Decoders.addDecoder(clazz: Customer.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Customer> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Customer() : instance as! Customer
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name_legal"] as AnyObject?) {
                
                case let .success(value): _result.nameLegal = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["street_1"] as AnyObject?) {
                
                case let .success(value): _result.street1 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["street_2"] as AnyObject?) {
                
                case let .success(value): _result.street2 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): _result.city = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zipcode"] as AnyObject?) {
                
                case let .success(value): _result.zipcode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                
                case let .success(value): _result.phone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["industry"] as AnyObject?) {
                
                case let .success(value): _result.industry = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Customer", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerCreateRequest]
        Decoders.addDecoder(clazz: [CustomerCreateRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerCreateRequest]> in
            return Decoders.decode(clazz: [CustomerCreateRequest].self, source: source)
        }

        // Decoder for CustomerCreateRequest
        Decoders.addDecoder(clazz: CustomerCreateRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerCreateRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerCreateRequest() : instance as! CustomerCreateRequest
                switch Decoders.decodeOptional(clazz: Customer.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): _result.customer = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomerUser.self, source: sourceDictionary["customer_user"] as AnyObject?) {
                
                case let .success(value): _result.customerUser = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomerLocation.self, source: sourceDictionary["customer_location"] as AnyObject?) {
                
                case let .success(value): _result.customerLocation = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerCreateRequest", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerLocation]
        Decoders.addDecoder(clazz: [CustomerLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerLocation]> in
            return Decoders.decode(clazz: [CustomerLocation].self, source: source)
        }

        // Decoder for CustomerLocation
        Decoders.addDecoder(clazz: CustomerLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerLocation() : instance as! CustomerLocation
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_id"] as AnyObject?) {
                
                case let .success(value): _result.customerId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["street_1"] as AnyObject?) {
                
                case let .success(value): _result.street1 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["street_2"] as AnyObject?) {
                
                case let .success(value): _result.street2 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): _result.city = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zipcode"] as AnyObject?) {
                
                case let .success(value): _result.zipcode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                
                case let .success(value): _result.phone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["site_name"] as AnyObject?) {
                
                case let .success(value): _result.siteName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomFormDataList.self, source: sourceDictionary["custom_forms"] as AnyObject?) {
                
                case let .success(value): _result.customForms = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [[UploadFile]].self, source: sourceDictionary["files"] as AnyObject?) {
                
                case let .success(value): _result.files = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["customer_ids"] as AnyObject?) {
                
                case let .success(value): _result.customerIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomerLocationMetadata.self, source: sourceDictionary["metadata_values"] as AnyObject?) {
                
                case let .success(value): _result.metadataValues = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomerTechnologySummary.self, source: sourceDictionary["technology"] as AnyObject?) {
                
                case let .success(value): _result.technology = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerLocation", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerLocationMetadata]
        Decoders.addDecoder(clazz: [CustomerLocationMetadata].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerLocationMetadata]> in
            return Decoders.decode(clazz: [CustomerLocationMetadata].self, source: source)
        }

        // Decoder for CustomerLocationMetadata
        Decoders.addDecoder(clazz: CustomerLocationMetadata.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerLocationMetadata> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerLocationMetadata() : instance as! CustomerLocationMetadata
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location_technology_notes"] as AnyObject?) {
                
                case let .success(value): _result.locationTechnologyNotes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_aspects_that_affect_connectivity"] as AnyObject?) {
                
                case let .success(value): _result.uniqueAspectsThatAffectConnectivity = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["terminal_identification_number"] as AnyObject?) {
                
                case let .success(value): _result.terminalIdentificationNumber = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerLocationMetadata", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerLocationPutRequest]
        Decoders.addDecoder(clazz: [CustomerLocationPutRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerLocationPutRequest]> in
            return Decoders.decode(clazz: [CustomerLocationPutRequest].self, source: source)
        }

        // Decoder for CustomerLocationPutRequest
        Decoders.addDecoder(clazz: CustomerLocationPutRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerLocationPutRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerLocationPutRequest() : instance as! CustomerLocationPutRequest
                switch Decoders.decodeOptional(clazz: CustomerLocation.self, source: sourceDictionary["customer_location"] as AnyObject?) {
                
                case let .success(value): _result.customerLocation = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerLocationPutRequest", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerTechnology]
        Decoders.addDecoder(clazz: [CustomerTechnology].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerTechnology]> in
            return Decoders.decode(clazz: [CustomerTechnology].self, source: source)
        }

        // Decoder for CustomerTechnology
        Decoders.addDecoder(clazz: CustomerTechnology.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerTechnology> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerTechnology() : instance as! CustomerTechnology
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent_id"] as AnyObject?) {
                
                case let .success(value): _result.parentId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_id"] as AnyObject?) {
                
                case let .success(value): _result.customerId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_location_id"] as AnyObject?) {
                
                case let .success(value): _result.customerLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["org_id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["nickname"] as AnyObject?) {
                
                case let .success(value): _result.nickname = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["critical"] as AnyObject?) {
                
                case let .success(value): _result.critical = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): _result.active = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["label"] as AnyObject?) {
                
                case let .success(value): _result.label = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["make"] as AnyObject?) {
                
                case let .success(value): _result.make = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["model"] as AnyObject?) {
                
                case let .success(value): _result.model = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["serial_number"] as AnyObject?) {
                
                case let .success(value): _result.serialNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                
                case let .success(value): _result.version = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ip_address"] as AnyObject?) {
                
                case let .success(value): _result.ipAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mac_adddress"] as AnyObject?) {
                
                case let .success(value): _result.macAdddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                
                case let .success(value): _result.location = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status_detail"] as AnyObject?) {
                
                case let .success(value): _result.statusDetail = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["last_checked"] as AnyObject?) {
                
                case let .success(value): _result.lastChecked = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["last_seen"] as AnyObject?) {
                
                case let .success(value): _result.lastSeen = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["last_changed"] as AnyObject?) {
                
                case let .success(value): _result.lastChanged = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pci_ssc_ref_no"] as AnyObject?) {
                
                case let .success(value): _result.pciSscRefNo = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pts_device_dependencies"] as AnyObject?) {
                
                case let .success(value): _result.ptsDeviceDependencies = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["app_pa_dss_listed"] as AnyObject?) {
                
                case let .success(value): _result.appPaDssListed = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["pa_dds_expire_date"] as AnyObject?) {
                
                case let .success(value): _result.paDdsExpireDate = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomerTechnologyMetadata.self, source: sourceDictionary["metadata_values"] as AnyObject?) {
                
                case let .success(value): _result.metadataValues = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pci_compliant"] as AnyObject?) {
                
                case let .success(value): _result.pciCompliant = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["policy"] as AnyObject?) {
                
                case let .success(value): _result.policy = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerTechnology", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerTechnologyMetadata]
        Decoders.addDecoder(clazz: [CustomerTechnologyMetadata].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerTechnologyMetadata]> in
            return Decoders.decode(clazz: [CustomerTechnologyMetadata].self, source: source)
        }

        // Decoder for CustomerTechnologyMetadata
        Decoders.addDecoder(clazz: CustomerTechnologyMetadata.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerTechnologyMetadata> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerTechnologyMetadata() : instance as! CustomerTechnologyMetadata
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["download_consumed"] as AnyObject?) {
                
                case let .success(value): _result.downloadConsumed = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["upload_consumed"] as AnyObject?) {
                
                case let .success(value): _result.uploadConsumed = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["network_at_pos_station"] as AnyObject?) {
                
                case let .success(value): _result.networkAtPosStation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["pos_emv_nfc"] as AnyObject?) {
                
                case let .success(value): _result.posEmvNfc = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pos_org"] as AnyObject?) {
                
                case let .success(value): _result.posOrg = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["power_at_pos_station"] as AnyObject?) {
                
                case let .success(value): _result.powerAtPosStation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["terminal_id"] as AnyObject?) {
                
                case let .success(value): _result.terminalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerTechnologyMetadata", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerTechnologySummary]
        Decoders.addDecoder(clazz: [CustomerTechnologySummary].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerTechnologySummary]> in
            return Decoders.decode(clazz: [CustomerTechnologySummary].self, source: source)
        }

        // Decoder for CustomerTechnologySummary
        Decoders.addDecoder(clazz: CustomerTechnologySummary.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerTechnologySummary> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerTechnologySummary() : instance as! CustomerTechnologySummary
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent_id"] as AnyObject?) {
                
                case let .success(value): _result.parentId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["critical"] as AnyObject?) {
                
                case let .success(value): _result.critical = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): _result.active = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["make"] as AnyObject?) {
                
                case let .success(value): _result.make = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["model"] as AnyObject?) {
                
                case let .success(value): _result.model = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["last_checked"] as AnyObject?) {
                
                case let .success(value): _result.lastChecked = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["last_seen"] as AnyObject?) {
                
                case let .success(value): _result.lastSeen = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["last_changed"] as AnyObject?) {
                
                case let .success(value): _result.lastChanged = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pci_compliant"] as AnyObject?) {
                
                case let .success(value): _result.pciCompliant = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["policy"] as AnyObject?) {
                
                case let .success(value): _result.policy = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerTechnologySummary", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerTuple]
        Decoders.addDecoder(clazz: [CustomerTuple].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerTuple]> in
            return Decoders.decode(clazz: [CustomerTuple].self, source: source)
        }

        // Decoder for CustomerTuple
        Decoders.addDecoder(clazz: CustomerTuple.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerTuple> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerTuple() : instance as! CustomerTuple
                switch Decoders.decodeOptional(clazz: Customer.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): _result.customer = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomerUser.self, source: sourceDictionary["customer_user"] as AnyObject?) {
                
                case let .success(value): _result.customerUser = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomerLocation.self, source: sourceDictionary["customer_location"] as AnyObject?) {
                
                case let .success(value): _result.customerLocation = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerTuple", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerUser]
        Decoders.addDecoder(clazz: [CustomerUser].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerUser]> in
            return Decoders.decode(clazz: [CustomerUser].self, source: source)
        }

        // Decoder for CustomerUser
        Decoders.addDecoder(clazz: CustomerUser.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerUser> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerUser() : instance as! CustomerUser
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_id"] as AnyObject?) {
                
                case let .success(value): _result.customerId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_location_id"] as AnyObject?) {
                
                case let .success(value): _result.customerLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?) {
                
                case let .success(value): _result.firstName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?) {
                
                case let .success(value): _result.lastName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["full_name"] as AnyObject?) {
                
                case let .success(value): _result.fullName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sms_number"] as AnyObject?) {
                
                case let .success(value): _result.smsNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lang"] as AnyObject?) {
                
                case let .success(value): _result.lang = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerUser", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerUserPutRequest]
        Decoders.addDecoder(clazz: [CustomerUserPutRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerUserPutRequest]> in
            return Decoders.decode(clazz: [CustomerUserPutRequest].self, source: source)
        }

        // Decoder for CustomerUserPutRequest
        Decoders.addDecoder(clazz: CustomerUserPutRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerUserPutRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerUserPutRequest() : instance as! CustomerUserPutRequest
                switch Decoders.decodeOptional(clazz: CustomerUser.self, source: sourceDictionary["customer_user"] as AnyObject?) {
                
                case let .success(value): _result.customerUser = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerUserPutRequest", actual: "\(source)"))
            }
        }
        // Decoder for [Emoticon]
        Decoders.addDecoder(clazz: [Emoticon].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Emoticon]> in
            return Decoders.decode(clazz: [Emoticon].self, source: source)
        }

        // Decoder for Emoticon
        Decoders.addDecoder(clazz: Emoticon.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Emoticon> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Emoticon() : instance as! Emoticon
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lbl"] as AnyObject?) {
                
                case let .success(value): _result.lbl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shorthand"] as AnyObject?) {
                
                case let .success(value): _result.shorthand = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Emoticon", actual: "\(source)"))
            }
        }
        // Decoder for [EnumerationItem]
        Decoders.addDecoder(clazz: [EnumerationItem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EnumerationItem]> in
            return Decoders.decode(clazz: [EnumerationItem].self, source: source)
        }

        // Decoder for EnumerationItem
        Decoders.addDecoder(clazz: EnumerationItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EnumerationItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EnumerationItem() : instance as! EnumerationItem
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): _result.value = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EnumerationItem", actual: "\(source)"))
            }
        }
        // Decoder for [ExistsResponse]
        Decoders.addDecoder(clazz: [ExistsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ExistsResponse]> in
            return Decoders.decode(clazz: [ExistsResponse].self, source: source)
        }

        // Decoder for ExistsResponse
        Decoders.addDecoder(clazz: ExistsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExistsResponse> in
            if let source = source as? ExistsResponse {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias ExistsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [HashMapOfStrings]
        Decoders.addDecoder(clazz: [HashMapOfStrings].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HashMapOfStrings]> in
            return Decoders.decode(clazz: [HashMapOfStrings].self, source: source)
        }

        // Decoder for HashMapOfStrings
        Decoders.addDecoder(clazz: HashMapOfStrings.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HashMapOfStrings> in
            if let source = source as? HashMapOfStrings {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias HashMapOfStrings", actual: "\(source)"))
            }
        }
        // Decoder for [Issue]
        Decoders.addDecoder(clazz: [Issue].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Issue]> in
            return Decoders.decode(clazz: [Issue].self, source: source)
        }

        // Decoder for Issue
        Decoders.addDecoder(clazz: Issue.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Issue> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Issue() : instance as! Issue
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reference_num"] as AnyObject?) {
                
                case let .success(value): _result.referenceNum = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["remote_id"] as AnyObject?) {
                
                case let .success(value): _result.remoteId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_id"] as AnyObject?) {
                
                case let .success(value): _result.customerId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_name"] as AnyObject?) {
                
                case let .success(value): _result.customerName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_email"] as AnyObject?) {
                
                case let .success(value): _result.customerEmail = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_location_id"] as AnyObject?) {
                
                case let .success(value): _result.customerLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_location_name"] as AnyObject?) {
                
                case let .success(value): _result.customerLocationName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_user_id"] as AnyObject?) {
                
                case let .success(value): _result.customerUserId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_user_name"] as AnyObject?) {
                
                case let .success(value): _result.customerUserName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_user_email"] as AnyObject?) {
                
                case let .success(value): _result.customerUserEmail = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): _result.userId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): _result.category = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["details"] as AnyObject?) {
                
                case let .success(value): _result.details = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["job"] as AnyObject?) {
                
                case let .success(value): _result.job = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["resolution"] as AnyObject?) {
                
                case let .success(value): _result.resolution = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["scheduled_time"] as AnyObject?) {
                
                case let .success(value): _result.scheduledTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["enroute_time"] as AnyObject?) {
                
                case let .success(value): _result.enrouteTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["arrival_time"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["departure_time"] as AnyObject?) {
                
                case let .success(value): _result.departureTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["idr_isq"] as AnyObject?) {
                
                case let .success(value): _result.idrIsq = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["idr_process"] as AnyObject?) {
                
                case let .success(value): _result.idrProcess = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["idr_resolution"] as AnyObject?) {
                
                case let .success(value): _result.idrResolution = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["tech_support_minutes"] as AnyObject?) {
                
                case let .success(value): _result.techSupportMinutes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["special_notes"] as AnyObject?) {
                
                case let .success(value): _result.specialNotes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["unmanaged"] as AnyObject?) {
                
                case let .success(value): _result.unmanaged = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: IssueMetadata.self, source: sourceDictionary["metadata_values"] as AnyObject?) {
                
                case let .success(value): _result.metadataValues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Issue", actual: "\(source)"))
            }
        }
        // Decoder for [IssueChatHistory]
        Decoders.addDecoder(clazz: [IssueChatHistory].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueChatHistory]> in
            return Decoders.decode(clazz: [IssueChatHistory].self, source: source)
        }

        // Decoder for IssueChatHistory
        Decoders.addDecoder(clazz: IssueChatHistory.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueChatHistory> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueChatHistory() : instance as! IssueChatHistory
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["object_id"] as AnyObject?) {
                
                case let .success(value): _result.objectId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["object_scope"] as AnyObject?) {
                
                case let .success(value): _result.objectScope = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["chat_type"] as AnyObject?) {
                
                case let .success(value): _result.chatType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["chat_status"] as AnyObject?) {
                
                case let .success(value): _result.chatStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["billing_status"] as AnyObject?) {
                
                case let .success(value): _result.billingStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subtitle"] as AnyObject?) {
                
                case let .success(value): _result.subtitle = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["duration_plus"] as AnyObject?) {
                
                case let .success(value): _result.durationPlus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["duration"] as AnyObject?) {
                
                case let .success(value): _result.duration = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: IssueChatHistoryTranscript.self, source: sourceDictionary["transcript"] as AnyObject?) {
                
                case let .success(value): _result.transcript = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_rpid"] as AnyObject?) {
                
                case let .success(value): _result.externalRpid = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_lpid"] as AnyObject?) {
                
                case let .success(value): _result.externalLpid = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueChatHistory", actual: "\(source)"))
            }
        }
        // Decoder for [IssueChatHistoryTranscript]
        Decoders.addDecoder(clazz: [IssueChatHistoryTranscript].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueChatHistoryTranscript]> in
            return Decoders.decode(clazz: [IssueChatHistoryTranscript].self, source: source)
        }

        // Decoder for IssueChatHistoryTranscript
        Decoders.addDecoder(clazz: IssueChatHistoryTranscript.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueChatHistoryTranscript> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueChatHistoryTranscript() : instance as! IssueChatHistoryTranscript
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["chat_id"] as AnyObject?) {
                
                case let .success(value): _result.chatId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["participant"] as AnyObject?) {
                
                case let .success(value): _result.participant = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["participant_id"] as AnyObject?) {
                
                case let .success(value): _result.participantId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): _result.timestamp = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["hadPayload"] as AnyObject?) {
                
                case let .success(value): _result.hadPayload = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["text"] as AnyObject?) {
                
                case let .success(value): _result.text = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): _result.user = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["chat"] as AnyObject?) {
                
                case let .success(value): _result.chat = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueChatHistoryTranscript", actual: "\(source)"))
            }
        }
        // Decoder for [IssueCreateRequest]
        Decoders.addDecoder(clazz: [IssueCreateRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueCreateRequest]> in
            return Decoders.decode(clazz: [IssueCreateRequest].self, source: source)
        }

        // Decoder for IssueCreateRequest
        Decoders.addDecoder(clazz: IssueCreateRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueCreateRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueCreateRequest() : instance as! IssueCreateRequest
                switch Decoders.decodeOptional(clazz: Issue.self, source: sourceDictionary["issues"] as AnyObject?) {
                
                case let .success(value): _result.issues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueCreateRequest", actual: "\(source)"))
            }
        }
        // Decoder for [IssueLog]
        Decoders.addDecoder(clazz: [IssueLog].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueLog]> in
            return Decoders.decode(clazz: [IssueLog].self, source: source)
        }

        // Decoder for IssueLog
        Decoders.addDecoder(clazz: IssueLog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueLog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueLog() : instance as! IssueLog
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["issues_id"] as AnyObject?) {
                
                case let .success(value): _result.issuesId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["diff_log"] as AnyObject?) {
                
                case let .success(value): _result.diffLog = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueLog", actual: "\(source)"))
            }
        }
        // Decoder for [IssueMetadata]
        Decoders.addDecoder(clazz: [IssueMetadata].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueMetadata]> in
            return Decoders.decode(clazz: [IssueMetadata].self, source: source)
        }

        // Decoder for IssueMetadata
        Decoders.addDecoder(clazz: IssueMetadata.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueMetadata> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueMetadata() : instance as! IssueMetadata
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferred_install_date"] as AnyObject?) {
                
                case let .success(value): _result.preferredInstallDate = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["preferred_time_frame"] as AnyObject?) {
                
                case let .success(value): _result.preferredTimeFrame = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["alternate_install_date"] as AnyObject?) {
                
                case let .success(value): _result.alternateInstallDate = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["alternate_time_frame"] as AnyObject?) {
                
                case let .success(value): _result.alternateTimeFrame = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_pos_devices"] as AnyObject?) {
                
                case let .success(value): _result.numberOfPosDevices = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueMetadata", actual: "\(source)"))
            }
        }
        // Decoder for [IssueStatus]
        Decoders.addDecoder(clazz: [IssueStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueStatus]> in
            return Decoders.decode(clazz: [IssueStatus].self, source: source)
        }

        // Decoder for IssueStatus
        Decoders.addDecoder(clazz: IssueStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueStatus> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueStatus() : instance as! IssueStatus
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["resolution"] as AnyObject?) {
                
                case let .success(value): _result.resolution = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["scheduled_time"] as AnyObject?) {
                
                case let .success(value): _result.scheduledTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ticketSummaryText"] as AnyObject?) {
                
                case let .success(value): _result.ticketSummaryText = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["historySummaryText"] as AnyObject?) {
                
                case let .success(value): _result.historySummaryText = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueStatus", actual: "\(source)"))
            }
        }
        // Decoder for [Org]
        Decoders.addDecoder(clazz: [Org].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Org]> in
            return Decoders.decode(clazz: [Org].self, source: source)
        }

        // Decoder for Org
        Decoders.addDecoder(clazz: Org.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Org> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Org() : instance as! Org
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name_legal"] as AnyObject?) {
                
                case let .success(value): _result.nameLegal = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["nickname"] as AnyObject?) {
                
                case let .success(value): _result.nickname = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["chat_id"] as AnyObject?) {
                
                case let .success(value): _result.chatId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["street_1"] as AnyObject?) {
                
                case let .success(value): _result.street1 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["street_2"] as AnyObject?) {
                
                case let .success(value): _result.street2 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): _result.city = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zipcode"] as AnyObject?) {
                
                case let .success(value): _result.zipcode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["default_org_team_id"] as AnyObject?) {
                
                case let .success(value): _result.defaultOrgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                
                case let .success(value): _result.phone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["website"] as AnyObject?) {
                
                case let .success(value): _result.website = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["avatar"] as AnyObject?) {
                
                case let .success(value): _result.avatar = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Org", actual: "\(source)"))
            }
        }
        // Decoder for [OrgReportItem]
        Decoders.addDecoder(clazz: [OrgReportItem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrgReportItem]> in
            return Decoders.decode(clazz: [OrgReportItem].self, source: source)
        }

        // Decoder for OrgReportItem
        Decoders.addDecoder(clazz: OrgReportItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrgReportItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrgReportItem() : instance as! OrgReportItem
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Issue ID"] as AnyObject?) {
                
                case let .success(value): _result.issueID = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Reference Num"] as AnyObject?) {
                
                case let .success(value): _result.referenceNum = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Cases/Tickets"] as AnyObject?) {
                
                case let .success(value): _result.orgCasesTickets = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Issue Status"] as AnyObject?) {
                
                case let .success(value): _result.issueStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Job Status"] as AnyObject?) {
                
                case let .success(value): _result.jobStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Admin User / Org Team User"] as AnyObject?) {
                
                case let .success(value): _result.adminUserOrgTeamUser = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Issue Type"] as AnyObject?) {
                
                case let .success(value): _result.issueType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Work Order Type"] as AnyObject?) {
                
                case let .success(value): _result.workOrderType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Issue Category"] as AnyObject?) {
                
                case let .success(value): _result.issueCategory = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Customer Name"] as AnyObject?) {
                
                case let .success(value): _result.customerName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Customer Location Site Name"] as AnyObject?) {
                
                case let .success(value): _result.customerLocationSiteName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Customer Location Street 1"] as AnyObject?) {
                
                case let .success(value): _result.customerLocationStreet1 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Customer Location Street 2"] as AnyObject?) {
                
                case let .success(value): _result.customerLocationStreet2 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["City"] as AnyObject?) {
                
                case let .success(value): _result.city = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["State"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Zipcode"] as AnyObject?) {
                
                case let .success(value): _result.zipcode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Country"] as AnyObject?) {
                
                case let .success(value): _result.country = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Time Zone of Scheduled/Action Date and Time"] as AnyObject?) {
                
                case let .success(value): _result.timeZoneOfScheduledActionDateAndTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["Issue Creation Date and Time"] as AnyObject?) {
                
                case let .success(value): _result.issueCreationDateAndTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["Date and Time Scheduled by Project Manager"] as AnyObject?) {
                
                case let .success(value): _result.dateAndTimeScheduledByProjectManager = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["Scheduled Date and Time"] as AnyObject?) {
                
                case let .success(value): _result.scheduledDateAndTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["Start Date and Time"] as AnyObject?) {
                
                case let .success(value): _result.startDateAndTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["Resolved Date and Time"] as AnyObject?) {
                
                case let .success(value): _result.resolvedDateAndTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Remote Wait Time"] as AnyObject?) {
                
                case let .success(value): _result.remoteWaitTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Service Time"] as AnyObject?) {
                
                case let .success(value): _result.serviceTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Resolution"] as AnyObject?) {
                
                case let .success(value): _result.resolution = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["NPS"] as AnyObject?) {
                
                case let .success(value): _result.NPS = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Technician Rating"] as AnyObject?) {
                
                case let .success(value): _result.technicianRating = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Total"] as AnyObject?) {
                
                case let .success(value): _result.total = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Payment Status"] as AnyObject?) {
                
                case let .success(value): _result.paymentStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Special Notes"] as AnyObject?) {
                
                case let .success(value): _result.specialNotes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Tech Support Minutes"] as AnyObject?) {
                
                case let .success(value): _result.techSupportMinutes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrgReportItem", actual: "\(source)"))
            }
        }
        // Decoder for [OrgTeam]
        Decoders.addDecoder(clazz: [OrgTeam].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrgTeam]> in
            return Decoders.decode(clazz: [OrgTeam].self, source: source)
        }

        // Decoder for OrgTeam
        Decoders.addDecoder(clazz: OrgTeam.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrgTeam> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrgTeam() : instance as! OrgTeam
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["nickname"] as AnyObject?) {
                
                case let .success(value): _result.nickname = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                
                case let .success(value): _result.phone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["avatar"] as AnyObject?) {
                
                case let .success(value): _result.avatar = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["auto_assign_route"] as AnyObject?) {
                
                case let .success(value): _result.autoAssignRoute = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["auto_assign_sponsor"] as AnyObject?) {
                
                case let .success(value): _result.autoAssignSponsor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["exclusive"] as AnyObject?) {
                
                case let .success(value): _result.exclusive = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                
                case let .success(value): _result.published = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["published_name"] as AnyObject?) {
                
                case let .success(value): _result.publishedName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["private_label"] as AnyObject?) {
                
                case let .success(value): _result.privateLabel = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["link_color"] as AnyObject?) {
                
                case let .success(value): _result.linkColor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["text_color"] as AnyObject?) {
                
                case let .success(value): _result.textColor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["brand_color1"] as AnyObject?) {
                
                case let .success(value): _result.brandColor1 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["brand_color2"] as AnyObject?) {
                
                case let .success(value): _result.brandColor2 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["brand_logo_1x"] as AnyObject?) {
                
                case let .success(value): _result.brandLogo1x = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["brand_logo_2x"] as AnyObject?) {
                
                case let .success(value): _result.brandLogo2x = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["brand_logo_3x"] as AnyObject?) {
                
                case let .success(value): _result.brandLogo3x = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["support_email"] as AnyObject?) {
                
                case let .success(value): _result.supportEmail = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["support_phone"] as AnyObject?) {
                
                case let .success(value): _result.supportPhone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["support_url"] as AnyObject?) {
                
                case let .success(value): _result.supportUrl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrgTeam", actual: "\(source)"))
            }
        }
        // Decoder for [OrgTeamCreateRequest]
        Decoders.addDecoder(clazz: [OrgTeamCreateRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrgTeamCreateRequest]> in
            return Decoders.decode(clazz: [OrgTeamCreateRequest].self, source: source)
        }

        // Decoder for OrgTeamCreateRequest
        Decoders.addDecoder(clazz: OrgTeamCreateRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrgTeamCreateRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrgTeamCreateRequest() : instance as! OrgTeamCreateRequest
                switch Decoders.decodeOptional(clazz: OrgTeam.self, source: sourceDictionary["org_team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrgTeamCreateRequest", actual: "\(source)"))
            }
        }
        // Decoder for [OrgUser]
        Decoders.addDecoder(clazz: [OrgUser].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrgUser]> in
            return Decoders.decode(clazz: [OrgUser].self, source: source)
        }

        // Decoder for OrgUser
        Decoders.addDecoder(clazz: OrgUser.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrgUser> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrgUser() : instance as! OrgUser
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?) {
                
                case let .success(value): _result.firstName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?) {
                
                case let .success(value): _result.lastName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sms_number"] as AnyObject?) {
                
                case let .success(value): _result.smsNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_id"] as AnyObject?) {
                
                case let .success(value): _result.externalId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["time_zone"] as AnyObject?) {
                
                case let .success(value): _result.timeZone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["present"] as AnyObject?) {
                
                case let .success(value): _result.present = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrgUser", actual: "\(source)"))
            }
        }
        // Decoder for [OrgUserCreateRequest]
        Decoders.addDecoder(clazz: [OrgUserCreateRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrgUserCreateRequest]> in
            return Decoders.decode(clazz: [OrgUserCreateRequest].self, source: source)
        }

        // Decoder for OrgUserCreateRequest
        Decoders.addDecoder(clazz: OrgUserCreateRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrgUserCreateRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrgUserCreateRequest() : instance as! OrgUserCreateRequest
                switch Decoders.decodeOptional(clazz: OrgUser.self, source: sourceDictionary["users"] as AnyObject?) {
                
                case let .success(value): _result.users = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrgUserCreateRequest", actual: "\(source)"))
            }
        }
        // Decoder for [ReportHeadersItem]
        Decoders.addDecoder(clazz: [ReportHeadersItem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportHeadersItem]> in
            return Decoders.decode(clazz: [ReportHeadersItem].self, source: source)
        }

        // Decoder for ReportHeadersItem
        Decoders.addDecoder(clazz: ReportHeadersItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportHeadersItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportHeadersItem() : instance as! ReportHeadersItem
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["priority"] as AnyObject?) {
                
                case let .success(value): _result.priority = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportHeadersItem", actual: "\(source)"))
            }
        }
        // Decoder for [ReportHeadersResponse]
        Decoders.addDecoder(clazz: [ReportHeadersResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportHeadersResponse]> in
            return Decoders.decode(clazz: [ReportHeadersResponse].self, source: source)
        }

        // Decoder for ReportHeadersResponse
        Decoders.addDecoder(clazz: ReportHeadersResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportHeadersResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportHeadersResponse() : instance as! ReportHeadersResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportHeadersResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIActiveSupportMinutesResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIActiveSupportMinutesResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIActiveSupportMinutesResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIActiveSupportMinutesResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIActiveSupportMinutesResponseResults
        Decoders.addDecoder(clazz: ReportingKPIActiveSupportMinutesResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIActiveSupportMinutesResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIActiveSupportMinutesResponseResults() : instance as! ReportingKPIActiveSupportMinutesResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Category"] as AnyObject?) {
                
                case let .success(value): _result.category = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["# Support Minutes"] as AnyObject?) {
                
                case let .success(value): _result.supportMinutes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIActiveSupportMinutesResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIAverageTimeToScheduledResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIAverageTimeToScheduledResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIAverageTimeToScheduledResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIAverageTimeToScheduledResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIAverageTimeToScheduledResponseResults
        Decoders.addDecoder(clazz: ReportingKPIAverageTimeToScheduledResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIAverageTimeToScheduledResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIAverageTimeToScheduledResponseResults() : instance as! ReportingKPIAverageTimeToScheduledResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Category"] as AnyObject?) {
                
                case let .success(value): _result.category = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Average Days To Scheduled"] as AnyObject?) {
                
                case let .success(value): _result.averageDaysToScheduled = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIAverageTimeToScheduledResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesByAgeResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesByAgeResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesByAgeResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesByAgeResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIIssuesByAgeResponseResults
        Decoders.addDecoder(clazz: ReportingKPIIssuesByAgeResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesByAgeResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesByAgeResponseResults() : instance as! ReportingKPIIssuesByAgeResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["Last 24 hrs"] as AnyObject?) {
                
                case let .success(value): _result.last24Hrs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["Last 7 days"] as AnyObject?) {
                
                case let .success(value): _result.last7Days = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["Last 30 days"] as AnyObject?) {
                
                case let .success(value): _result.last30Days = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["All Time"] as AnyObject?) {
                
                case let .success(value): _result.allTime = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesByAgeResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesByCategoryResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesByCategoryResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesByCategoryResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesByCategoryResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIIssuesByCategoryResponseResults
        Decoders.addDecoder(clazz: ReportingKPIIssuesByCategoryResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesByCategoryResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesByCategoryResponseResults() : instance as! ReportingKPIIssuesByCategoryResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Category"] as AnyObject?) {
                
                case let .success(value): _result.category = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["# Issues"] as AnyObject?) {
                
                case let .success(value): _result.issues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesByCategoryResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesByGeographyResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesByGeographyResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesByGeographyResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesByGeographyResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIIssuesByGeographyResponseResults
        Decoders.addDecoder(clazz: ReportingKPIIssuesByGeographyResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesByGeographyResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesByGeographyResponseResults() : instance as! ReportingKPIIssuesByGeographyResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Division Unit"] as AnyObject?) {
                
                case let .success(value): _result.divisionUnit = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Division Value"] as AnyObject?) {
                
                case let .success(value): _result.divisionValue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Issues"] as AnyObject?) {
                
                case let .success(value): _result.issues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesByGeographyResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesByLocationResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesByLocationResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesByLocationResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesByLocationResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIIssuesByLocationResponseResults
        Decoders.addDecoder(clazz: ReportingKPIIssuesByLocationResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesByLocationResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesByLocationResponseResults() : instance as! ReportingKPIIssuesByLocationResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Site Id"] as AnyObject?) {
                
                case let .success(value): _result.siteId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Customer"] as AnyObject?) {
                
                case let .success(value): _result.customer = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Site Name"] as AnyObject?) {
                
                case let .success(value): _result.siteName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Issues"] as AnyObject?) {
                
                case let .success(value): _result.issues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesByLocationResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesOverTimeResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesOverTimeResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesOverTimeResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesOverTimeResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIIssuesOverTimeResponseResults
        Decoders.addDecoder(clazz: ReportingKPIIssuesOverTimeResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesOverTimeResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesOverTimeResponseResults() : instance as! ReportingKPIIssuesOverTimeResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Category"] as AnyObject?) {
                
                case let .success(value): _result.category = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Interval Label"] as AnyObject?) {
                
                case let .success(value): _result.intervalLabel = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Interval Date"] as AnyObject?) {
                
                case let .success(value): _result.intervalDate = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["Interval"] as AnyObject?) {
                
                case let .success(value): _result.interval = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Issues"] as AnyObject?) {
                
                case let .success(value): _result.issues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesOverTimeResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesRemoteVsOnsiteResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesRemoteVsOnsiteResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesRemoteVsOnsiteResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesRemoteVsOnsiteResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIIssuesRemoteVsOnsiteResponseResults
        Decoders.addDecoder(clazz: ReportingKPIIssuesRemoteVsOnsiteResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesRemoteVsOnsiteResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesRemoteVsOnsiteResponseResults() : instance as! ReportingKPIIssuesRemoteVsOnsiteResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Remote Issues"] as AnyObject?) {
                
                case let .success(value): _result.remoteIssues = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["% Remote"] as AnyObject?) {
                
                case let .success(value): _result.remote = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Onsite Issues"] as AnyObject?) {
                
                case let .success(value): _result.onsiteIssues = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["% Onsite"] as AnyObject?) {
                
                case let .success(value): _result.onsite = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Total Issues"] as AnyObject?) {
                
                case let .success(value): _result.totalIssues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesRemoteVsOnsiteResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesTimeToCompletionResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesTimeToCompletionResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesTimeToCompletionResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesTimeToCompletionResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIIssuesTimeToCompletionResponseResults
        Decoders.addDecoder(clazz: ReportingKPIIssuesTimeToCompletionResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesTimeToCompletionResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesTimeToCompletionResponseResults() : instance as! ReportingKPIIssuesTimeToCompletionResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Average Time To Completion"] as AnyObject?) {
                
                case let .success(value): _result.averageTimeToCompletion = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["Sum Time To Completion"] as AnyObject?) {
                
                case let .success(value): _result.sumTimeToCompletion = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Time Interval"] as AnyObject?) {
                
                case let .success(value): _result.timeInterval = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Category"] as AnyObject?) {
                
                case let .success(value): _result.category = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Issues"] as AnyObject?) {
                
                case let .success(value): _result.issues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesTimeToCompletionResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIOpenIssuesResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIOpenIssuesResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIOpenIssuesResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIOpenIssuesResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIOpenIssuesResponseResults
        Decoders.addDecoder(clazz: ReportingKPIOpenIssuesResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIOpenIssuesResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIOpenIssuesResponseResults() : instance as! ReportingKPIOpenIssuesResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Customer"] as AnyObject?) {
                
                case let .success(value): _result.customer = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Site Name"] as AnyObject?) {
                
                case let .success(value): _result.siteName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Category"] as AnyObject?) {
                
                case let .success(value): _result.category = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["Claimed"] as AnyObject?) {
                
                case let .success(value): _result.claimed = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIOpenIssuesResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIOrgOwnedIssuesResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPIOrgOwnedIssuesResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIOrgOwnedIssuesResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPIOrgOwnedIssuesResponseResults].self, source: source)
        }

        // Decoder for ReportingKPIOrgOwnedIssuesResponseResults
        Decoders.addDecoder(clazz: ReportingKPIOrgOwnedIssuesResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIOrgOwnedIssuesResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIOrgOwnedIssuesResponseResults() : instance as! ReportingKPIOrgOwnedIssuesResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Support Issues"] as AnyObject?) {
                
                case let .success(value): _result.supportIssues = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Work Order Issues"] as AnyObject?) {
                
                case let .success(value): _result.workOrderIssues = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIOrgOwnedIssuesResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPITimeOnsiteByLocationResponseResults]
        Decoders.addDecoder(clazz: [ReportingKPITimeOnsiteByLocationResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPITimeOnsiteByLocationResponseResults]> in
            return Decoders.decode(clazz: [ReportingKPITimeOnsiteByLocationResponseResults].self, source: source)
        }

        // Decoder for ReportingKPITimeOnsiteByLocationResponseResults
        Decoders.addDecoder(clazz: ReportingKPITimeOnsiteByLocationResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPITimeOnsiteByLocationResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPITimeOnsiteByLocationResponseResults() : instance as! ReportingKPITimeOnsiteByLocationResponseResults
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Id"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org"] as AnyObject?) {
                
                case let .success(value): _result.org = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team Id"] as AnyObject?) {
                
                case let .success(value): _result.orgTeamId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Org Team"] as AnyObject?) {
                
                case let .success(value): _result.orgTeam = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Site Id"] as AnyObject?) {
                
                case let .success(value): _result.siteId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Site Name"] as AnyObject?) {
                
                case let .success(value): _result.siteName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["# Onsite Issues"] as AnyObject?) {
                
                case let .success(value): _result.onsiteIssues = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Total Time Onsite"] as AnyObject?) {
                
                case let .success(value): _result.totalTimeOnsite = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Average Time Onsite"] as AnyObject?) {
                
                case let .success(value): _result.averageTimeOnsite = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Time Interval"] as AnyObject?) {
                
                case let .success(value): _result.timeInterval = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPITimeOnsiteByLocationResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [Shipment]
        Decoders.addDecoder(clazz: [Shipment].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Shipment]> in
            return Decoders.decode(clazz: [Shipment].self, source: source)
        }

        // Decoder for Shipment
        Decoders.addDecoder(clazz: Shipment.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Shipment> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Shipment() : instance as! Shipment
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["pieces"] as AnyObject?) {
                
                case let .success(value): _result.pieces = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["carrier"] as AnyObject?) {
                
                case let .success(value): _result.carrier = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["carrier_tracking"] as AnyObject?) {
                
                case let .success(value): _result.carrierTracking = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["estimated_arrival"] as AnyObject?) {
                
                case let .success(value): _result.estimatedArrival = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): _result.updated = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Shipment", actual: "\(source)"))
            }
        }
        // Decoder for [ShipmentCreateRequest]
        Decoders.addDecoder(clazz: [ShipmentCreateRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ShipmentCreateRequest]> in
            return Decoders.decode(clazz: [ShipmentCreateRequest].self, source: source)
        }

        // Decoder for ShipmentCreateRequest
        Decoders.addDecoder(clazz: ShipmentCreateRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ShipmentCreateRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ShipmentCreateRequest() : instance as! ShipmentCreateRequest
                switch Decoders.decodeOptional(clazz: Shipment.self, source: sourceDictionary["shipments"] as AnyObject?) {
                
                case let .success(value): _result.shipments = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ShipmentCreateRequest", actual: "\(source)"))
            }
        }
        // Decoder for [SmsInviteResponse]
        Decoders.addDecoder(clazz: [SmsInviteResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SmsInviteResponse]> in
            return Decoders.decode(clazz: [SmsInviteResponse].self, source: source)
        }

        // Decoder for SmsInviteResponse
        Decoders.addDecoder(clazz: SmsInviteResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SmsInviteResponse> in
            if let source = source as? SmsInviteResponse {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias SmsInviteResponse", actual: "\(source)"))
            }
        }
        // Decoder for [TechnicianReportItem]
        Decoders.addDecoder(clazz: [TechnicianReportItem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TechnicianReportItem]> in
            return Decoders.decode(clazz: [TechnicianReportItem].self, source: source)
        }

        // Decoder for TechnicianReportItem
        Decoders.addDecoder(clazz: TechnicianReportItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TechnicianReportItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TechnicianReportItem() : instance as! TechnicianReportItem
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Technician ID"] as AnyObject?) {
                
                case let .success(value): _result.technicianID = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Technician Name"] as AnyObject?) {
                
                case let .success(value): _result.technicianName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Office Phone"] as AnyObject?) {
                
                case let .success(value): _result.officePhone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Cell Phone"] as AnyObject?) {
                
                case let .success(value): _result.cellPhone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["E-mail"] as AnyObject?) {
                
                case let .success(value): _result.eMail = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Technician Street 1"] as AnyObject?) {
                
                case let .success(value): _result.technicianStreet1 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Technician Street 2"] as AnyObject?) {
                
                case let .success(value): _result.technicianStreet2 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["City"] as AnyObject?) {
                
                case let .success(value): _result.city = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["State"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Zipcode"] as AnyObject?) {
                
                case let .success(value): _result.zipcode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Country"] as AnyObject?) {
                
                case let .success(value): _result.country = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Time Zone"] as AnyObject?) {
                
                case let .success(value): _result.timeZone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Nearest Metro"] as AnyObject?) {
                
                case let .success(value): _result.nearestMetro = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Hourly Rate"] as AnyObject?) {
                
                case let .success(value): _result.hourlyRate = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Travel Radius"] as AnyObject?) {
                
                case let .success(value): _result.travelRadius = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Average Travel Distance to Customer Location for Completed Work Orders"] as AnyObject?) {
                
                case let .success(value): _result.averageTravelDistanceToCustomerLocationForCompletedWorkOrders = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["# of Jobs Advertised"] as AnyObject?) {
                
                case let .success(value): _result.ofJobsAdvertised = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["# of Jobs Declined"] as AnyObject?) {
                
                case let .success(value): _result.ofJobsDeclined = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["# of Jobs No Response"] as AnyObject?) {
                
                case let .success(value): _result.ofJobsNoResponse = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["# of Jobs Canceled"] as AnyObject?) {
                
                case let .success(value): _result.ofJobsCanceled = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["# of Jobs Completed"] as AnyObject?) {
                
                case let .success(value): _result.ofJobsCompleted = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Average Technician Rating"] as AnyObject?) {
                
                case let .success(value): _result.averageTechnicianRating = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Average NPS"] as AnyObject?) {
                
                case let .success(value): _result.averageNPS = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["Average Margin %"] as AnyObject?) {
                
                case let .success(value): _result.averageMargin_ = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["On Time Performance"] as AnyObject?) {
                
                case let .success(value): _result.onTimePerformance = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["Date of Last Work Order"] as AnyObject?) {
                
                case let .success(value): _result.dateOfLastWorkOrder = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TechnicianReportItem", actual: "\(source)"))
            }
        }
        // Decoder for [TechnologyCreateRequest]
        Decoders.addDecoder(clazz: [TechnologyCreateRequest].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TechnologyCreateRequest]> in
            return Decoders.decode(clazz: [TechnologyCreateRequest].self, source: source)
        }

        // Decoder for TechnologyCreateRequest
        Decoders.addDecoder(clazz: TechnologyCreateRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TechnologyCreateRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TechnologyCreateRequest() : instance as! TechnologyCreateRequest
                switch Decoders.decodeOptional(clazz: CustomerTechnology.self, source: sourceDictionary["technology"] as AnyObject?) {
                
                case let .success(value): _result.technology = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TechnologyCreateRequest", actual: "\(source)"))
            }
        }
        // Decoder for [UploadFile]
        Decoders.addDecoder(clazz: [UploadFile].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UploadFile]> in
            return Decoders.decode(clazz: [UploadFile].self, source: source)
        }

        // Decoder for UploadFile
        Decoders.addDecoder(clazz: UploadFile.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UploadFile> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UploadFile() : instance as! UploadFile
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["object"] as AnyObject?) {
                
                case let .success(value): _result.object = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["object_id"] as AnyObject?) {
                
                case let .success(value): _result.objectId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file"] as AnyObject?) {
                
                case let .success(value): _result.file = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): _result.size = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tag"] as AnyObject?) {
                
                case let .success(value): _result.tag = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["thumbnail"] as AnyObject?) {
                
                case let .success(value): _result.thumbnail = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): _result.created = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UploadFile", actual: "\(source)"))
            }
        }
        // Decoder for [BaseResponse]
        Decoders.addDecoder(clazz: [BaseResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[BaseResponse]> in
            return Decoders.decode(clazz: [BaseResponse].self, source: source)
        }

        // Decoder for BaseResponse
        Decoders.addDecoder(clazz: BaseResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BaseResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? BaseResponse() : instance as! BaseResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "BaseResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CommonReportResponse]
        Decoders.addDecoder(clazz: [CommonReportResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CommonReportResponse]> in
            return Decoders.decode(clazz: [CommonReportResponse].self, source: source)
        }

        // Decoder for CommonReportResponse
        Decoders.addDecoder(clazz: CommonReportResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CommonReportResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CommonReportResponse() : instance as! CommonReportResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CommonReportResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ModelErrorResponse]
        Decoders.addDecoder(clazz: [ModelErrorResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ModelErrorResponse]> in
            return Decoders.decode(clazz: [ModelErrorResponse].self, source: source)
        }

        // Decoder for ModelErrorResponse
        Decoders.addDecoder(clazz: ModelErrorResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ModelErrorResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ModelErrorResponse() : instance as! ModelErrorResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ModelErrorResponse", actual: "\(source)"))
            }
        }
        // Decoder for [PhoneResponse]
        Decoders.addDecoder(clazz: [PhoneResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PhoneResponse]> in
            return Decoders.decode(clazz: [PhoneResponse].self, source: source)
        }

        // Decoder for PhoneResponse
        Decoders.addDecoder(clazz: PhoneResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PhoneResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? PhoneResponse() : instance as! PhoneResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["issue_id"] as AnyObject?) {
                
                case let .success(value): _result.issueId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "PhoneResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ChatSendResponse]
        Decoders.addDecoder(clazz: [ChatSendResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ChatSendResponse]> in
            return Decoders.decode(clazz: [ChatSendResponse].self, source: source)
        }

        // Decoder for ChatSendResponse
        Decoders.addDecoder(clazz: ChatSendResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChatSendResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ChatSendResponse() : instance as! ChatSendResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ChatSend].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ChatSendResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CustomFormsResponse]
        Decoders.addDecoder(clazz: [CustomFormsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomFormsResponse]> in
            return Decoders.decode(clazz: [CustomFormsResponse].self, source: source)
        }

        // Decoder for CustomFormsResponse
        Decoders.addDecoder(clazz: CustomFormsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomFormsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomFormsResponse() : instance as! CustomFormsResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CustomForm].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomFormsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerCreateResponse]
        Decoders.addDecoder(clazz: [CustomerCreateResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerCreateResponse]> in
            return Decoders.decode(clazz: [CustomerCreateResponse].self, source: source)
        }

        // Decoder for CustomerCreateResponse
        Decoders.addDecoder(clazz: CustomerCreateResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerCreateResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerCreateResponse() : instance as! CustomerCreateResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: CustomerTuple.self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerCreateResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerLocationResponse]
        Decoders.addDecoder(clazz: [CustomerLocationResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerLocationResponse]> in
            return Decoders.decode(clazz: [CustomerLocationResponse].self, source: source)
        }

        // Decoder for CustomerLocationResponse
        Decoders.addDecoder(clazz: CustomerLocationResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerLocationResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerLocationResponse() : instance as! CustomerLocationResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CustomerLocation].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerLocationResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerMetaEmoticonsResponse]
        Decoders.addDecoder(clazz: [CustomerMetaEmoticonsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerMetaEmoticonsResponse]> in
            return Decoders.decode(clazz: [CustomerMetaEmoticonsResponse].self, source: source)
        }

        // Decoder for CustomerMetaEmoticonsResponse
        Decoders.addDecoder(clazz: CustomerMetaEmoticonsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerMetaEmoticonsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerMetaEmoticonsResponse() : instance as! CustomerMetaEmoticonsResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Emoticon].self, source: sourceDictionary["emoticons"] as AnyObject?) {
                
                case let .success(value): _result.emoticons = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerMetaEmoticonsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerResponse]
        Decoders.addDecoder(clazz: [CustomerResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerResponse]> in
            return Decoders.decode(clazz: [CustomerResponse].self, source: source)
        }

        // Decoder for CustomerResponse
        Decoders.addDecoder(clazz: CustomerResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerResponse() : instance as! CustomerResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Customer].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerTechnologyResponse]
        Decoders.addDecoder(clazz: [CustomerTechnologyResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerTechnologyResponse]> in
            return Decoders.decode(clazz: [CustomerTechnologyResponse].self, source: source)
        }

        // Decoder for CustomerTechnologyResponse
        Decoders.addDecoder(clazz: CustomerTechnologyResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerTechnologyResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerTechnologyResponse() : instance as! CustomerTechnologyResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CustomerTechnology].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerTechnologyResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CustomerUserResponse]
        Decoders.addDecoder(clazz: [CustomerUserResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CustomerUserResponse]> in
            return Decoders.decode(clazz: [CustomerUserResponse].self, source: source)
        }

        // Decoder for CustomerUserResponse
        Decoders.addDecoder(clazz: CustomerUserResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerUserResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CustomerUserResponse() : instance as! CustomerUserResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CustomerUser].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerUserResponse", actual: "\(source)"))
            }
        }
        // Decoder for [EnumerationItemResponse]
        Decoders.addDecoder(clazz: [EnumerationItemResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EnumerationItemResponse]> in
            return Decoders.decode(clazz: [EnumerationItemResponse].self, source: source)
        }

        // Decoder for EnumerationItemResponse
        Decoders.addDecoder(clazz: EnumerationItemResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EnumerationItemResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EnumerationItemResponse() : instance as! EnumerationItemResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [EnumerationItem].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EnumerationItemResponse", actual: "\(source)"))
            }
        }
        // Decoder for [FilesResponse]
        Decoders.addDecoder(clazz: [FilesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FilesResponse]> in
            return Decoders.decode(clazz: [FilesResponse].self, source: source)
        }

        // Decoder for FilesResponse
        Decoders.addDecoder(clazz: FilesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FilesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FilesResponse() : instance as! FilesResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [UploadFile].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FilesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [HashMapResponse]
        Decoders.addDecoder(clazz: [HashMapResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HashMapResponse]> in
            return Decoders.decode(clazz: [HashMapResponse].self, source: source)
        }

        // Decoder for HashMapResponse
        Decoders.addDecoder(clazz: HashMapResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HashMapResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HashMapResponse() : instance as! HashMapResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: HashMapOfStrings.self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HashMapResponse", actual: "\(source)"))
            }
        }
        // Decoder for [IssueChatHistoryResponse]
        Decoders.addDecoder(clazz: [IssueChatHistoryResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueChatHistoryResponse]> in
            return Decoders.decode(clazz: [IssueChatHistoryResponse].self, source: source)
        }

        // Decoder for IssueChatHistoryResponse
        Decoders.addDecoder(clazz: IssueChatHistoryResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueChatHistoryResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueChatHistoryResponse() : instance as! IssueChatHistoryResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [IssueChatHistory].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueChatHistoryResponse", actual: "\(source)"))
            }
        }
        // Decoder for [IssueLogsResponse]
        Decoders.addDecoder(clazz: [IssueLogsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueLogsResponse]> in
            return Decoders.decode(clazz: [IssueLogsResponse].self, source: source)
        }

        // Decoder for IssueLogsResponse
        Decoders.addDecoder(clazz: IssueLogsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueLogsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueLogsResponse() : instance as! IssueLogsResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [IssueLog].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueLogsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [IssueResponse]
        Decoders.addDecoder(clazz: [IssueResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueResponse]> in
            return Decoders.decode(clazz: [IssueResponse].self, source: source)
        }

        // Decoder for IssueResponse
        Decoders.addDecoder(clazz: IssueResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueResponse() : instance as! IssueResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Issue].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueResponse", actual: "\(source)"))
            }
        }
        // Decoder for [IssueStatusesResponse]
        Decoders.addDecoder(clazz: [IssueStatusesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[IssueStatusesResponse]> in
            return Decoders.decode(clazz: [IssueStatusesResponse].self, source: source)
        }

        // Decoder for IssueStatusesResponse
        Decoders.addDecoder(clazz: IssueStatusesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IssueStatusesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? IssueStatusesResponse() : instance as! IssueStatusesResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [IssueStatus].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "IssueStatusesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [OrgResponse]
        Decoders.addDecoder(clazz: [OrgResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrgResponse]> in
            return Decoders.decode(clazz: [OrgResponse].self, source: source)
        }

        // Decoder for OrgResponse
        Decoders.addDecoder(clazz: OrgResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrgResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrgResponse() : instance as! OrgResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Org].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrgResponse", actual: "\(source)"))
            }
        }
        // Decoder for [OrgTeamResponse]
        Decoders.addDecoder(clazz: [OrgTeamResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrgTeamResponse]> in
            return Decoders.decode(clazz: [OrgTeamResponse].self, source: source)
        }

        // Decoder for OrgTeamResponse
        Decoders.addDecoder(clazz: OrgTeamResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrgTeamResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrgTeamResponse() : instance as! OrgTeamResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [OrgTeam].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrgTeamResponse", actual: "\(source)"))
            }
        }
        // Decoder for [OrgUserResponse]
        Decoders.addDecoder(clazz: [OrgUserResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[OrgUserResponse]> in
            return Decoders.decode(clazz: [OrgUserResponse].self, source: source)
        }

        // Decoder for OrgUserResponse
        Decoders.addDecoder(clazz: OrgUserResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OrgUserResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? OrgUserResponse() : instance as! OrgUserResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [OrgUser].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "OrgUserResponse", actual: "\(source)"))
            }
        }
        // Decoder for [QueueEnterResponse]
        Decoders.addDecoder(clazz: [QueueEnterResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[QueueEnterResponse]> in
            return Decoders.decode(clazz: [QueueEnterResponse].self, source: source)
        }

        // Decoder for QueueEnterResponse
        Decoders.addDecoder(clazz: QueueEnterResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<QueueEnterResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? QueueEnterResponse() : instance as! QueueEnterResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["issueId"] as AnyObject?) {
                
                case let .success(value): _result.issueId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "QueueEnterResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIActiveSupportMinutesResponse]
        Decoders.addDecoder(clazz: [ReportingKPIActiveSupportMinutesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIActiveSupportMinutesResponse]> in
            return Decoders.decode(clazz: [ReportingKPIActiveSupportMinutesResponse].self, source: source)
        }

        // Decoder for ReportingKPIActiveSupportMinutesResponse
        Decoders.addDecoder(clazz: ReportingKPIActiveSupportMinutesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIActiveSupportMinutesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIActiveSupportMinutesResponse() : instance as! ReportingKPIActiveSupportMinutesResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIActiveSupportMinutesResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIActiveSupportMinutesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIAverageTimeToScheduledResponse]
        Decoders.addDecoder(clazz: [ReportingKPIAverageTimeToScheduledResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIAverageTimeToScheduledResponse]> in
            return Decoders.decode(clazz: [ReportingKPIAverageTimeToScheduledResponse].self, source: source)
        }

        // Decoder for ReportingKPIAverageTimeToScheduledResponse
        Decoders.addDecoder(clazz: ReportingKPIAverageTimeToScheduledResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIAverageTimeToScheduledResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIAverageTimeToScheduledResponse() : instance as! ReportingKPIAverageTimeToScheduledResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIAverageTimeToScheduledResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIAverageTimeToScheduledResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesByAgeResponse]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesByAgeResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesByAgeResponse]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesByAgeResponse].self, source: source)
        }

        // Decoder for ReportingKPIIssuesByAgeResponse
        Decoders.addDecoder(clazz: ReportingKPIIssuesByAgeResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesByAgeResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesByAgeResponse() : instance as! ReportingKPIIssuesByAgeResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIIssuesByAgeResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesByAgeResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesByCategoryResponse]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesByCategoryResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesByCategoryResponse]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesByCategoryResponse].self, source: source)
        }

        // Decoder for ReportingKPIIssuesByCategoryResponse
        Decoders.addDecoder(clazz: ReportingKPIIssuesByCategoryResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesByCategoryResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesByCategoryResponse() : instance as! ReportingKPIIssuesByCategoryResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIIssuesByCategoryResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesByCategoryResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesByGeographyResponse]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesByGeographyResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesByGeographyResponse]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesByGeographyResponse].self, source: source)
        }

        // Decoder for ReportingKPIIssuesByGeographyResponse
        Decoders.addDecoder(clazz: ReportingKPIIssuesByGeographyResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesByGeographyResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesByGeographyResponse() : instance as! ReportingKPIIssuesByGeographyResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIIssuesByGeographyResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesByGeographyResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesByLocationResponse]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesByLocationResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesByLocationResponse]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesByLocationResponse].self, source: source)
        }

        // Decoder for ReportingKPIIssuesByLocationResponse
        Decoders.addDecoder(clazz: ReportingKPIIssuesByLocationResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesByLocationResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesByLocationResponse() : instance as! ReportingKPIIssuesByLocationResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIIssuesByLocationResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesByLocationResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesOverTimeResponse]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesOverTimeResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesOverTimeResponse]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesOverTimeResponse].self, source: source)
        }

        // Decoder for ReportingKPIIssuesOverTimeResponse
        Decoders.addDecoder(clazz: ReportingKPIIssuesOverTimeResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesOverTimeResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesOverTimeResponse() : instance as! ReportingKPIIssuesOverTimeResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIIssuesOverTimeResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesOverTimeResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesRemoteVsOnsiteResponse]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesRemoteVsOnsiteResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesRemoteVsOnsiteResponse]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesRemoteVsOnsiteResponse].self, source: source)
        }

        // Decoder for ReportingKPIIssuesRemoteVsOnsiteResponse
        Decoders.addDecoder(clazz: ReportingKPIIssuesRemoteVsOnsiteResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesRemoteVsOnsiteResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesRemoteVsOnsiteResponse() : instance as! ReportingKPIIssuesRemoteVsOnsiteResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIIssuesRemoteVsOnsiteResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesRemoteVsOnsiteResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIIssuesTimeToCompletionResponse]
        Decoders.addDecoder(clazz: [ReportingKPIIssuesTimeToCompletionResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIIssuesTimeToCompletionResponse]> in
            return Decoders.decode(clazz: [ReportingKPIIssuesTimeToCompletionResponse].self, source: source)
        }

        // Decoder for ReportingKPIIssuesTimeToCompletionResponse
        Decoders.addDecoder(clazz: ReportingKPIIssuesTimeToCompletionResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIIssuesTimeToCompletionResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIIssuesTimeToCompletionResponse() : instance as! ReportingKPIIssuesTimeToCompletionResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIIssuesTimeToCompletionResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIIssuesTimeToCompletionResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIOpenIssuesResponse]
        Decoders.addDecoder(clazz: [ReportingKPIOpenIssuesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIOpenIssuesResponse]> in
            return Decoders.decode(clazz: [ReportingKPIOpenIssuesResponse].self, source: source)
        }

        // Decoder for ReportingKPIOpenIssuesResponse
        Decoders.addDecoder(clazz: ReportingKPIOpenIssuesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIOpenIssuesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIOpenIssuesResponse() : instance as! ReportingKPIOpenIssuesResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIOpenIssuesResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIOpenIssuesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPIOrgOwnedIssuesResponse]
        Decoders.addDecoder(clazz: [ReportingKPIOrgOwnedIssuesResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPIOrgOwnedIssuesResponse]> in
            return Decoders.decode(clazz: [ReportingKPIOrgOwnedIssuesResponse].self, source: source)
        }

        // Decoder for ReportingKPIOrgOwnedIssuesResponse
        Decoders.addDecoder(clazz: ReportingKPIOrgOwnedIssuesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPIOrgOwnedIssuesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPIOrgOwnedIssuesResponse() : instance as! ReportingKPIOrgOwnedIssuesResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPIOrgOwnedIssuesResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPIOrgOwnedIssuesResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingKPITimeOnsiteByLocationResponse]
        Decoders.addDecoder(clazz: [ReportingKPITimeOnsiteByLocationResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingKPITimeOnsiteByLocationResponse]> in
            return Decoders.decode(clazz: [ReportingKPITimeOnsiteByLocationResponse].self, source: source)
        }

        // Decoder for ReportingKPITimeOnsiteByLocationResponse
        Decoders.addDecoder(clazz: ReportingKPITimeOnsiteByLocationResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingKPITimeOnsiteByLocationResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingKPITimeOnsiteByLocationResponse() : instance as! ReportingKPITimeOnsiteByLocationResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ReportingKPITimeOnsiteByLocationResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingKPITimeOnsiteByLocationResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingOrgsResponse]
        Decoders.addDecoder(clazz: [ReportingOrgsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingOrgsResponse]> in
            return Decoders.decode(clazz: [ReportingOrgsResponse].self, source: source)
        }

        // Decoder for ReportingOrgsResponse
        Decoders.addDecoder(clazz: ReportingOrgsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingOrgsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingOrgsResponse() : instance as! ReportingOrgsResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [OrgReportItem].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingOrgsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ReportingTechniciansResponse]
        Decoders.addDecoder(clazz: [ReportingTechniciansResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ReportingTechniciansResponse]> in
            return Decoders.decode(clazz: [ReportingTechniciansResponse].self, source: source)
        }

        // Decoder for ReportingTechniciansResponse
        Decoders.addDecoder(clazz: ReportingTechniciansResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReportingTechniciansResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ReportingTechniciansResponse() : instance as! ReportingTechniciansResponse
                switch Decoders.decodeOptional(clazz: [ReportHeadersItem].self, source: sourceDictionary["headers"] as AnyObject?) {
                
                case let .success(value): _result.headers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): _result.title = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TechnicianReportItem].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ReportingTechniciansResponse", actual: "\(source)"))
            }
        }
        // Decoder for [ShipmentResponse]
        Decoders.addDecoder(clazz: [ShipmentResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ShipmentResponse]> in
            return Decoders.decode(clazz: [ShipmentResponse].self, source: source)
        }

        // Decoder for ShipmentResponse
        Decoders.addDecoder(clazz: ShipmentResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ShipmentResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ShipmentResponse() : instance as! ShipmentResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Shipment].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ShipmentResponse", actual: "\(source)"))
            }
        }
        // Decoder for [TechnologyCreateResponse]
        Decoders.addDecoder(clazz: [TechnologyCreateResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TechnologyCreateResponse]> in
            return Decoders.decode(clazz: [TechnologyCreateResponse].self, source: source)
        }

        // Decoder for TechnologyCreateResponse
        Decoders.addDecoder(clazz: TechnologyCreateResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TechnologyCreateResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TechnologyCreateResponse() : instance as! TechnologyCreateResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CustomerTechnology].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TechnologyCreateResponse", actual: "\(source)"))
            }
        }
        // Decoder for [TechnologyDictionaryResponse]
        Decoders.addDecoder(clazz: [TechnologyDictionaryResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TechnologyDictionaryResponse]> in
            return Decoders.decode(clazz: [TechnologyDictionaryResponse].self, source: source)
        }

        // Decoder for TechnologyDictionaryResponse
        Decoders.addDecoder(clazz: TechnologyDictionaryResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TechnologyDictionaryResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TechnologyDictionaryResponse() : instance as! TechnologyDictionaryResponse
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["success"] as AnyObject?) {
                
                case let .success(value): _result.success = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["current_server_time"] as AnyObject?) {
                
                case let .success(value): _result.currentServerTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalCount"] as AnyObject?) {
                
                case let .success(value): _result.totalCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["returned"] as AnyObject?) {
                
                case let .success(value): _result.returned = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pages"] as AnyObject?) {
                
                case let .success(value): _result.pages = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): _result.message = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TechnologyDictionaryResponse", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
